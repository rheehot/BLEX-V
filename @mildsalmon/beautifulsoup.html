

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    
    <meta name="theme-color" content="#000">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113864080-4"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113864080-4');
    </script>
    

<meta name="description" content="소개 Beautiful Soup is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work. These instructions illustrate all major features of …">
<meta property="og:url" content="https://blex.kr/@mildsalmon/beautifulsoup">
<meta property="og:type" content="blog">
<meta property="og:title" content="beautifulsoup4 document">
<meta property="og:description" content="소개 Beautiful Soup is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work. These instructions illustrate all major features of …">
<meta property="og:site_name" content="BLEX">
<meta property="og:image" content="https://static.blex.kr/title/mildsalmon/2020/2/12/21UPtd.jpg">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="mildsalmon">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="beautifulsoup4 document">
<meta name="twitter:url" content="https://blex.kr/@mildsalmon/beautifulsoup">
<meta name="twitter:description" content="소개 Beautiful Soup is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work. These instructions illustrate all major features of …">
<meta name="twitter:image" content="https://static.blex.kr/title/mildsalmon/2020/2/12/21UPtd.jpg">

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
    <link rel="stylesheet" href="https://static.blex.kr/assets/library/bootstrap.css">
    <link rel="stylesheet" href="https://static.blex.kr/assets/library/prism.css">
    <link rel="stylesheet" href="https://static.blex.kr/assets/css/main.css?version=1.0.36">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+KR|Noto+Sans+KR">
    <link rel="icon" href="https://static.blex.kr/assets/images/logo.png">
    <title>beautifulsoup4 document – mildsalmon</title>
</head>
<body>
    

<style>.content {margin-top: 20px;} #mNavigation {background: rgba(0, 0, 0, 0); position: absolute;}</style>
<div>
    <picture class="post-title-image">
        <img src="https://static.blex.kr/title/mildsalmon/2020/2/12/21UPtd.jpg" alt="beautifulsoup4 document">
        <div class="post-image-mask">
            <h1 class="post-headline"><span class="post-series">'파이썬 모듈 문서' 시리즈</span>beautifulsoup4 document</h1>
            <p class="post-date">2020-02-12 16:29<span>(Last Update: 2020-02-21 00:17)<span></p>
        </div>
    </picture>
</div>


    
    <nav id="mNavigation" class="navbar navbar-expand-sm navbar-dark bg-theme fixed-top">
        <div class="container">
            <a class="navbar-brand" onmousedown="distoryLatelyPosition()" href="https://blex.kr">
                <img src="https://static.blex.kr/assets/images/logor.png" width="35" height="35" alt="">
            </a>
            
<ul class="navbar-nav">
    <li class="nav-item">
        <a class="nav-link" href="/@mildsalmon">mildsalmon</a>
    </li>
</ul>

    
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse justify-content-end" id="navbarNavAltMarkup">
            
<ul class="navbar-nav">
    <li class="nav-item">
        <a id="heart" class="nav-link" href="javascript:void(0);" onclick="posts.like(341);">
            <i class="far fa-heart"></i> <span id="like-count">1</span>
        </a>
    </li>
    
    <li class="nav-item">
        <a class="nav-link" href="javascript:void(0)" onclick="moveSlide('comment')">
            <i class="far fa-comment"></i> 0
        </a>
    </li>
    
    <li class="nav-item">
        <div class="dropdown">
            <a class="nav-link" href="#" role="button" id="dropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"">
                <i class="fas fa-share-alt"></i>
            </a>
            <div class="dropdown-menu" aria-labelledby="dropdownMenuLink">
                <a class="dropdown-item" target="_blank" href="https://facebook.com/sharer.php?u=https://blex.kr/@mildsalmon/beautifulsoup" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;"><i class="fab fa-facebook-square"></i> Facebook</a>
                <a class="dropdown-item" target="_blank" href="https://twitter.com/intent/tweet?text=beautifulsoup4 document&url=https://blex.kr/@mildsalmon/beautifulsoup" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"><i class="fab fa-twitter-square"></i> Twitter</a>
            </div>
        </div>
    </li>
</ul>

            
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="content">
        
<div class="row">
    <div class="ml-auto col-lg-8">
        
        
        <div class="row post-top-meta" onmousedown="distoryLatelyPosition()">
    <a href="/@mildsalmon">
        
        <div class="back-image thumb author-thumb" style="background-image:url(https://static.blex.kr/avatar/u/mildsalmon/CaDW.jpg)"></div>
        
    </a>
    <div class="author-info">
        <h4><a href="/@mildsalmon">mildsalmon</a><span class="ns ml-2"><i class="fas fa-battery-half"></i> 60%</span></h4>
            
            <p class="author-description">작은 불편함을 해소하기 위해 개발하는 연구원.</p>
            
            <ul class="author-state">
                <li>
                    <img src="https://img.shields.io/badge/-blogger-gray">
                </li>
                <li onclick="userFollow('mildsalmon')">
                    <img class="follow-badge" src="https://img.shields.io/badge/subscriber-0-red?style=social">
                </li>
            </ul>
            
            <a class="author-email d-block" href="/login">Sign in to view email</a>
            
        </p>
    </div>
</div>
        <article class="article noto">
            <h1>소개</h1>
<blockquote>
<p>Beautiful Soup is a Python library for pulling data out of HTML and XML files. It works with your favorite parser to provide idiomatic ways of navigating, searching, and modifying the parse tree. It commonly saves programmers hours or days of work.</p>
<p>These instructions illustrate all major features of Beautiful Soup 4, with examples. I show you what the library is good for, how it works, how to use it, how to make it do what you want, and what to do when it violates your expectations.</p>
<p>This document covers Beautiful Soup version 4.8.1. The examples in this documentation should work the same way in Python 2.7 and Python 3.2.
You might be looking for the documentation for Beautiful Soup 3. If so, you should know that Beautiful Soup 3 is no longer being developed and that support for it will be dropped on or after December 31, 2020. If you want to learn about the differences between Beautiful Soup 3 and Beautiful Soup 4, see Porting code to BS4.</p>
<p>This documentation has been translated into other languages by Beautiful Soup users:</p>
</blockquote>
<blockquote>
<p>뷰티플수프는 <code>HTML과 XML 파일로부터 데이터를 뽑아내기 위한 파이썬 라이브러리</code>이다. 여러분이 선호하는 해석기와 함께 사용하여 일반적인 방식으로 해석 트리를 항해, 검색, 변경할 수 있다. 주로 프로그래머의 수고를 덜어준다.</p>
<p>이 지도서에서는 뷰티플수프 4의 중요한 특징들을 예제와 함께 모두 보여준다. 이 라이브러리가 어느 곳에 유용한지, 어떻게 작동하는지, 또 어떻게 사용하는지, 어떻게 원하는대로 바꿀 수 있는지, 예상을 빗나갔을 때 어떻게 해야 하는지를 보여준다.</p>
<p>이 문서의 예제들은 <code>파이썬 2.7과 Python 3.2에서 똑 같이 작동한다.</code></p>
<p>혹시 뷰티플수프 3에 관한 문서를 찾고 계신다면 <code>뷰티플수프 3는 더 이상 개발되지 않는다</code>는 사실을 꼭 아셔야겠다. 새로 프로젝트를 시작한다면 뷰티플수프 4를 적극 추천한다. 뷰티플수프 3와 뷰티플수프 4의 차이점은 BS4 코드 이식하기를 참조하자.</p>
</blockquote>
<p>즉 beautifulsoup는 잘못된 HTML을 수정하여 쉽게 탑색할 수 있는 XML형식의 파이썬 객체로 변환한다.</p>
<h1>설치</h1>
<h3>BeautifulSoup 4 설치</h3>
<h4>데미안, 우분투 리눅스 (최신버전)</h4>
<ul>
<li>시스템 꾸러미 관리자로 설치하는 방법</li>
</ul>
<pre><code>$ apt-get install python-bs4</code></pre>
<ul>
<li>시스템 꾸러미 관리자로 설치할 수 없을 경우 <code>easy_install</code>이나 <code>pip</code>로 설치할 수 있다.</li>
</ul>
<pre><code>$ easy_install beautifulsoup4
$ pip install beautifulsoup4</code></pre>
<ul>
<li><code>easy_install</code>도 <code>pip</code>도 설치되어 있지 않다면, <a href="https://www.crummy.com/software/BeautifulSoup/bs4/download/4.0/" title="beautifulsoup4">beautifulsoup4</a> 를 내려 받아 <code>setup.py</code>로 설치할 수 있다.</li>
</ul>
<pre><code>$ python setup.py install</code></pre>
<h3>parser</h3>
<pre><code>Beautifulsoup(변환할 웹을 포함하는 변수)</code></pre>
<p><del>이렇게 코딩하면 기본적으로 파이썬의 html.parser가 자동으로 파싱된다</del>
20.01.23 기준 위 처럼 코딩하면 에러가 발생해서 아래처럼 parser를 명시해줘야한다.</p>
<pre><code>Beautifulsoup(변환할 웹을 포함하는 변수, "html.parser")</code></pre>
<ul>
<li>파이썬의 html.parser<pre><code>BeautifulSoup(markup, "html.parser")</code></pre>
</li>
</ul>
<ul>
<li>장점
각종 기능 완비
적절한 속도
관대함 (파이썬 2.7.3과 3.2에서.)</li>
<li>단점
별로 관대하지 않음 (파이썬 2.7.3이나 3.2.2 이전 버전에서)</li>
</ul>
<ul>
<li>lxml의 HTML 해석기<pre><code>BeautifulSoup(markup, "lxml")</code></pre>
</li>
</ul>
<ul>
<li>장점
아주 빠름
관대함</li>
<li>단점
외부 C 라이브러리 의존</li>
</ul>
<ul>
<li>lxml의 XML 해석기<pre><code>BeautifulSoup(markup, ["lxml", "xml"])
BeautifulSoup(markup, "xml")</code></pre>
</li>
</ul>
<ul>
<li>장점
아주 빠름
유일하게 XML 해석기 지원</li>
<li>단점
외부 C 라이브러리 의존</li>
</ul>
<ul>
<li>html5lib<pre><code>BeautifulSoup(markup, html5lib)</code></pre>
</li>
</ul>
<ul>
<li>장점
아주 관대함
웹 브라우저의 방식으로 페이지를 해석함
유효한 HTML5를 생성함</li>
<li>단점
아주 느림
외부 파이썬 라이브러리 의존
파이썬 2 전용</li>
</ul>
<p>lxml의 경우 따로 설치를 해야한다.</p>
<pre><code>$ apt-get install python-lxml

$ easy_install lxml

$ pip install lxml</code></pre>
<h4>parser 명시해 사용하기</h4>
<p>단지 HTML만 해석하고 싶을 경우, 조판을 BeautifulSoup 구성자에 넣기만 하면, 아마도 잘 처리될 것이다. 뷰티플수프는 해석기를 여러분 대신 선택해 데이터를 해석한다. 그러나 어느 해석기를 사용할지 바꾸기 위해 구성자에 건넬 수 있는 인자가 몇 가지 더 있다.</p>
<p>BeautifulSoup 구성자에 건네는 <code>첫 번째 인자는 문자열이나 열린 파일핸들-즉 해석하기를 원하는 조판이 첫 번째 인자</code>이다. <code>두 번째 인자는 그 조판이 어떻게 해석되기를 바라는지 지정한다</code>.</p>
<p>아무것도 지정하지 않으면, 설치된 해석기중 최적의 HTML 해석기가 배당된다. 뷰티플수프는 <code>lxml 해석기를 최선으로 취급하고, 다음에 html5lib 해석기, 그 다음이 파이썬의 내장 해석기</code>를 선택한다. 이것은 다음 중 하나로 덮어쓸 수 있다:</p>
<p>해석하고 싶은 조판의 종류. 현재 “html”, “xml”, 그리고 “html5”가 지원된다.
사용하고 싶은 해석기의 이름. 현재 선택은 “lxml”, “html5lib”, 그리고 “html.parser” (파이썬의 내장 HTML 해석기)이다.
해석기 설치하기 섹션에 지원 해석기들을 비교해 놓았다.</p>
<p>적절한 해석기가 설치되어 있지 않다면, 뷰티플수프는 여러분의 요구를 무시하고 다른 해석기를 선택한다. 지금 유일하게 지원되는 XML 해석기는 lxml이다. lxml 해석기가 설치되어 있지 않으면, XML 해석기를 요구할 경우 아무것도 얻을 수 없고, “lxml”을 요구하더라도 얻을 수 없다.</p>
<h4>해석기 사이의 차이점</h4>
<p>해석기마다 같은 문서에서 다른 해석 트리를 만들어낸다. 가장 큰 차이점은 HTML 해석기와 XML 해석기 사이에 있다. 다음은 HTML로 해석된 짧은 문서이다:</p>
<pre><code class="language-python">BeautifulSoup("&lt;a&gt;&lt;b /&gt;&lt;/a&gt;")

# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
<p>빈 <code>&lt;b /&gt;</code> 태그는 유효한 HTML이 아니므로, 해석기는 그것을 <code>&lt;b&gt;&lt;/b&gt;</code> 태그 쌍으로 변환한다.</p>
<p>다음 똑같은 문서를 XML로 해석한 것이다 (이를 실행하려면 lxml이 설치되어 있어야 한다). 빈 <code>&lt;b /&gt;</code> 태그가 홀로 남았음에 유의하자. 그리고 <code>&lt;html&gt;</code> 태그를 출력하는 대신에 XML 선언이 주어졌음을 주목하자:</p>
<pre><code class="language-python">BeautifulSoup("&lt;a&gt;&lt;b /&gt;&lt;/a&gt;", "xml")

# &lt;?xml version="1.0" encoding="utf-8"?&gt;
# &lt;a&gt;&lt;b /&gt;&lt;/a&gt;</code></pre>
<p>HTML 해석기 사이에서도 차이가 있다. 뷰티플수프에 완벽하게 모양을 갖춘 HTML 문서를 주면, 이 차이는 문제가 되지 않는다. 비록 해석기마다 속도에 차이가 있기는 하지만, 모두 원래의 HTML 문서와 정확하게 똑같이 보이는 데이터 구조를 돌려준다.</p>
<p>그러나 문서가 <code>불완전하게 모양을 갖추었다면, 해석기마다 결과가 다르다.</code> 다음은 짧은 무효한 문서를 lxml의 HTML 해석기로 해석한 것이다. 나홀로 <code>&lt;/p&gt;</code> 태그는 그냥 무시된다:</p>
<pre><code class="language-python">BeautifulSoup("&lt;a&gt;&lt;/p&gt;", "lxml")

# &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
<p>다음은 같은 문서를 html5lib로 해석하였다:</p>
<pre><code class="language-python">BeautifulSoup("&lt;a&gt;&lt;/p&gt;", "html5lib")

# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
<p>나홀로 <code>&lt;/p&gt;</code> 태그를 무시하는 대신에, html5lib는 여는 <code>&lt;p&gt;</code> 태그로 짝을 맞추어 준다. 이 해석기는 또한 빈 <code>&lt;head&gt;</code> 태그를 문서에 추가한다.</p>
<p>다음은 같은 문서를 파이썬 내장 HTML 해석기로 해석한 것이다:</p>
<pre><code class="language-python">BeautifulSoup("&lt;a&gt;&lt;/p&gt;", "html.parser")
# &lt;a&gt;&lt;/a&gt;</code></pre>
<p>html5lib처럼, 이 해석기는 닫는 <code>&lt;/p&gt;</code> 태그를 무시한다. html5lib와 다르게, 이 해석기는 <code>&lt;body&gt;</code> 태그를 추가해서 모양을 갖춘 HTML 문서를 생성하려고 아무 시도도 하지 않는다. lxml과 다르게, 심지어 <code>&lt;html&gt;</code> 태그를 추가하는 것에도 신경쓰지 않는다.</p>
<p>문서 <code>&lt;a&gt;&lt;/p&gt;</code>는 무효하므로, 이 테크닉중 어느 것도 “올바른” 처리 방법이 아니다. html5lib 해석기는 HTML5 표준에 있는 테크닉을 사용하므로, 아무래도 “가장 올바른” 방법이라고 주장할 수 있지만, 세 가지 테크닉 모두 같은 주장을 할 수 있다.</p>
<p>해석기 사이의 차이점 때문에 스크립트가 영향을 받을 수 있다. 스크립트를 다른 사람들에게 나누어 줄 계획이 있다면, 또는 여러 머신에서 실행할 생각이라면, <code>BeautifulSoup 구성자에 해석기를 지정해 주는 편이 좋다.</code> 그렇게 해야 여러분이 해석한 방식과 다르게 사용자가 문서를 해석할 위험성이 감소한다.</p>
<h1>soup 만들기</h1>
<p>문서를 해석하려면, 문서를 BeautifulSoup 구성자에 건네주자. 문자열 혹은 열린 파일 핸들을 건네면 된다.</p>
<pre><code class="language-python">from bs4 import BeautifulSoup

soup = BeautifulSoup(open("index.html"))
soup = BeautifulSoup("&lt;html&gt;data&lt;/html&gt;","html.parser")</code></pre>
<p>먼저, 문서는 <code>유니코드</code>로 변환되고 HTML 개체는 <code>유니코드 문자</code>로 변환된다.</p>
<pre><code class="language-python">BeautifulSoup("Sacr&amp;eacute; bleu!")
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacré bleu!&lt;/body&gt;&lt;/html&gt;  </code></pre>
<p>다음 뷰티플수프는 문서를 가장 적당한 해석기를 사용하여 해석한다. 특별히 XML 해석기를 사용하라고 지정해 주지 않으면 HTML 해석기를 사용한다.</p>
<h1>객체</h1>
<h3>BeautifulSoup 객체</h3>
<p>BeautifulSoup 객체 자신은 문서 전체를 대표한다. 대부분의 목적에, 그것을 Tag 객체로 취급해도 좋다. 이것은 곧 트리 항해하기와 트리 검색하기에 기술된 메쏘드들을 지원한다는 뜻이다.</p>
<p>BeautifulSoup 객체는 실제 HTML 태그나 XML 태그에 상응하지 않기 때문에, 이름도 속성도 없다. 그러나 가끔 그의 이름 .name을 살펴보는 것이 유용할 경우가 있다. 그래서 특별히 .name에 “[document]”라는 이름이 주어졌다</p>
<pre><code class="language-python">print(soup.name)</code></pre>
<pre><code># [document]</code></pre>
<h3>Tag 객체</h3>
<pre><code class="language-python">soup = BeautifulSoup('&lt;div class="section" id="tag"&gt;&lt;/div&gt;',"html.parser")
tag = soup.div
type(tag)</code></pre>
<p>Tag 객체는 원래 문서의 XML 태그 또는 HTML 태그에 상응한다.
태그는 많은 속성과 메쏘드가 있다.</p>
<h4>이름</h4>
<p>태그마다 이름이 있다
다음과 같이 <code>.name</code>으로 접근할 수 있다.
태그의 이름을 바꾸면, 그 변화는 뷰티블수프가 생산한 HTML 조판에 반영된다:</p>
<pre><code class="language-python">soup = BeautifulSoup('&lt;div class="section" id="tag"&gt;&lt;/div&gt;',"html.parser")
tag = soup.div
print(tag.name)
print(tag)
tag.name = "hi"
print(tag)
print(soup)</code></pre>
<pre><code># div
# &lt;div class="section" id="tag"&gt;&lt;/div&gt;
# &lt;hi class="section" id="tag"&gt;&lt;/hi&gt;
# &lt;hi class="section" id="tag"&gt;&lt;/hi&gt;</code></pre>
<h4>속성</h4>
<p>태그는 속성을 여러개 가질 수 있다. <code>&lt;b class="boldest"&gt;</code> 태그는 속성으로 “class”가 있는데 그 값은 “boldest”이다.</p>
<pre><code class="language-python">print(tag['class'])</code></pre>
<pre><code># ['section']</code></pre>
<p>딕셔너리에 <code>.attrs</code>와 같이 바로 접근할 수 있다</p>
<pre><code class="language-python">print(tag.attrs)</code></pre>
<pre><code># {'class': ['section'], 'id': 'tag'}</code></pre>
<p>태그의 속성을 추가, 제거, 변경할 수 있다. 역시 태그를 딕셔너리처럼 취급해서 처리한다</p>
<ul>
<li>추가</li>
</ul>
<pre><code class="language-python">tag['class'] = 'verybold'
tag['my'] = 1
print(tag)</code></pre>
<pre><code># &lt;div class="verybold" id="tag" my="1"&gt;&lt;/div&gt;</code></pre>
<ul>
<li>변경</li>
</ul>
<pre><code class="language-python">tag['class'] = 'change'
print(tag.get('class'))</code></pre>
<pre><code># change</code></pre>
<ul>
<li>제거</li>
</ul>
<pre><code class="language-python">del tag['class']
del tag['id']
print(tag)</code></pre>
<pre><code># &lt;div my="1"&gt;&lt;/div&gt;</code></pre>
<ul>
<li>값이 여럿인 속성 <strong>(잘 작동 안하는거 같다)</strong></li>
</ul>
<p>HTML 4에서 몇몇 속성은 값을 여러 개 가질 수 있도록 정의된다. HTML 5에서 그 중 2개는 제거되었지만, 몇 가지가 더 정의되었다. 가장 흔한 다중값 속성은 class이다 (다시 말해, 태그가 하나 이상의 CSS 클래스를 가질 수 있다). 다른 것으로는 rel, rev, accept-charset, headers, 그리고 accesskey가 포함된다. 뷰티플수프는 다중-값 속성의 값들을 <code>리스트</code>로 나타낸다:</p>
<pre><code class="language-python">css_soup = BeautifulSoup('&lt;div class="section tv" id="tag"&gt;&lt;/div&gt;',"html.parser")
print(css_soup.div['class'])
css_soup = BeautifulSoup('&lt;div class="section" id="tag"&gt;&lt;/div&gt;',"html.parser")
print(css_soup.div['class'])</code></pre>
<pre><code># ['section', 'tv']
# ['section']</code></pre>
<p>속성에 하나 이상의 값이 있는 것처럼 보이지만, HTML 표준에 정의된 다중-값 속성이 아니라면, 뷰티플수프는 그 속성을 그대로 둔다.</p>
<p>하지만 위에 section tv에서 tv는 HTML 표준이 아닐텐데 속성 값이 리스트에 들어갔다. 왜 그런지 모르겠다</p>
<pre><code class="language-python">id_soup = BeautifulSoup('&lt;p id="my id"&gt;&lt;/p&gt;')
id_soup.p['id']
# 'my id'</code></pre>
<p>태그를 다시 문자열로 바꾸면, 다중-값 속성은 합병된다:</p>
<pre><code class="language-python">rel_soup = BeautifulSoup('&lt;p&gt;Back to the &lt;a rel="index"&gt;homepage&lt;/a&gt;&lt;/p&gt;')
rel_soup.a['rel']
# ['index']
rel_soup.a['rel'] = ['index', 'contents']
print(rel_soup.p)
# &lt;p&gt;Back to the &lt;a rel="index contents"&gt;homepage&lt;/a&gt;&lt;/p&gt;</code></pre>
<p>문서를 XML로 해석하면, 다중-값 속성은 없다:</p>
<pre><code class="language-python">xml_soup = BeautifulSoup('&lt;p class="body strikeout"&gt;&lt;/p&gt;', 'xml')
xml_soup.p['class']
# u'body strikeout'</code></pre>
<h3>NavigableString 객체</h3>
<p>문자열은 태그 안에 있는 일군의 텍스트에 상응한다. 뷰티플수프는 NavigableString 클래스 안에다 이런 텍스트를 보관한다:</p>
<pre><code class="language-python">soup = BeautifulSoup('&lt;div class="my id" id="tag"&gt;hi&lt;/div&gt;',"html.parser")
tag = soup.div
print(tag.string)
print(type(tag.string))</code></pre>
<pre><code># hi
# &lt;class 'bs4.element.NavigableString'&gt;</code></pre>
<h3>Comment 객체</h3>
<p>주석 태그 안에 들어있는 HTML 주석(<!-- it -->)을 찾는데 사용한다.</p>
<pre><code class="language-python">soup = BeautifulSoup('&lt;div class="my id" id="tag"&gt;hi&lt;/div&gt;',"html.parser")
tag = soup.div
comment = soup.div.string
print(type(comment))
markup = "&lt;b&gt;&lt;!--Hey, i am comment--&gt;&lt;/b&gt;"
soup = BeautifulSoup(markup, "html.parser")
comment = soup.b.string
print(type(comment))</code></pre>
<pre><code># &lt;class 'bs4.element.NavigableString'&gt;
# &lt;class 'bs4.element.Comment'&gt;</code></pre>
<p>Comment 객체는 그냥 특별한 유형의 NavigableString이다</p>
<pre><code class="language-python">print(comment)</code></pre>
<pre><code># Hey, i am comment</code></pre>
<h1>트리 이동하기</h1>
<p>html 문서</p>
<pre><code>&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;
   The Dormouse's story
  &lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p class="title"&gt;
   &lt;b&gt;
    The Dormouse's story
   &lt;/b&gt;
  &lt;/p&gt;
  &lt;p class="story"&gt;
   Once upon a time there were three little sisters; and their names were
   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
    Elsie
   &lt;/a&gt;
   ,
   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
    Lacie
   &lt;/a&gt;
   and
   &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
    Tillie
   &lt;/a&gt;
   ; and they lived at the bottom of a well.
  &lt;/p&gt;
  &lt;p class="story"&gt;
   ...
  &lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3>내려가기</h3>
<p>태그에는 또 다른 태그가 담길 수 있다. 이런 요소들은 그 태그의 자식(children)이라고 부른다. beautifulSoup는 한 태그의 자식을 항해하고 반복하기 위한 속성을 다양하게 제공한다.</p>
<p>beautifulSoup의 문자열은 이런 속성을 제공하지 않음에 유의하자. 왜냐하면 문자열은 자식을 가질 수 없기 때문이다.</p>
<h4>태그 이름을 사용하여 이동하기</h4>
<p>가장 단순하게 해석 트리를 이동하는 방법은 원하는 태그의 이름을 지정해 주는 것이다.</p>
<pre><code class="language-python">print(soup.head)
print(soup.title)</code></pre>
<pre><code># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre>
<p>이 방법을 반복 사용하면 해석 트리의 특정 부분을 확대해 볼 수 있다.</p>
<pre><code class="language-python">print(soup.body.b)</code></pre>
<pre><code># &lt;b&gt;The Dormouse's story&lt;/b&gt;</code></pre>
<p>태그 이름을 속성으로 사용하면 오직 그 이름으로 된 첫 번째 태그만 얻는다.</p>
<pre><code class="language-python">print(soup.a)</code></pre>
<pre><code>&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</code></pre>
<p>태그의 자식은 <code>.contents</code>라고 부르는 리스트로 얻을 수 있다.</p>
<pre><code class="language-python">head_tag = soup.head
print(head_tag)
print(head_tag.contents)

title_tag = head_tag.contents[0]
print(title_tag)</code></pre>
<pre><code># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</code></pre>
<p><code>print(title_tag.contents)</code>는 AttributeError(속성오류) 발생한다.
<code>AttributeError: 'NavigableString' object has no attribute 'contents'</code></p>
<p>BeautifulSoup 객체 자체에도 자식이 있다. <code>&lt;html&gt;</code> 태그가 BeautifulSoup 객체의 자식이다.</p>
<pre><code class="language-python">print(len(soup.contents))</code></pre>
<pre><code># 1</code></pre>
<p>1이 아니라 3이 나온다면 <code>\n</code> 이 개행문자 2개가 요소로 들어가 있어서이다.</p>
<h4>.descendants</h4>
<p>내용물(.contents)과 자식(.children)속성은 오직 한 태그의 직계(direct)자식만 고려한다.
<code>&lt;head&gt;</code>태그는 오직 한 개의 직계 자식으로 <code>&lt;title&gt;</code> 태그가 있다.</p>
<pre><code class="language-python">print(soup.head.contents)</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</code></pre>
<p>그러나 <code>&lt;title&gt;</code> 태그 자체에 문자열 The Dormouse's story 이라는 자식이 하나 있다. 그 문자열도 역시 <code>&lt;head&gt;</code>의 자손이다. <code>.descendants</code> 속성은 한 태그의 자손을 모두 재귀적으로, 반복할 수 있도록 해준다.</p>
<pre><code class="language-python">head_tag = soup.head
for child in head_tag.descendants:
    print(child)</code></pre>
<pre><code># &lt;title&gt;The Dormouse's story&lt;/title&gt;
# The Dormouse's story</code></pre>
<p><code>&lt;head&gt;</code> 태그는 오직 자식이 하나이지만, 자손은 둘이다. <code>&lt;title&gt; 태그</code>와 <code>&lt;title&gt; 태그의 자손</code>.</p>
<pre><code class="language-python">print(len(list(soup.children)))
print(len(list(soup.descendants)))</code></pre>
<pre><code># 3
# 34</code></pre>
<p>정상적인 결과는 1과 25여야 한다. 하지만 결과가 이렇게 나온 이유는 <code>\n</code> 개행문자가 카운트되어서이다.</p>
<h4>.string</h4>
<p>태그에 오직 자식이 하나라면, 그리고 그 자식이 NavigableString이라면 그 자식은 <code>.string</code>으로 얻을 수 있다.</p>
<p>태그의 유일한 자식이 또다른 태그이고 그 태그가 <code>.string</code>을 가진다면 그 부모 태그는 같은 <code>.string</code>을 그의 자식으로 가진다고 간주한다.</p>
<pre><code class="language-python">head_tag = soup.head
title_tag = head_tag.contents[0]

print(title_tag.string)
print(head_tag.contents)
print(head_tag.string)</code></pre>
<pre><code># The Dormouse's story
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]
# The Dormouse's story</code></pre>
<p>그리고 태그에 하나 이상의 태그가 있다면, <code>.string</code>이 무엇을 가리킬지 확실하지 않다. 따라서 <code>.string</code>은 <code>None</code>으로 정의된다.</p>
<pre><code class="language-python">print(soup.html.string)</code></pre>
<pre><code># None</code></pre>
<h4>.strings AND stripped_strings</h4>
<p>한 태그 안에 여러개의 태그가 있더라도 여전히 문자열을 볼 수 있다.</p>
<pre><code class="language-python">for string in soup.strings:
    print(repr(string))</code></pre>
<pre><code>'\n'
# '\n'
# "The Dormouse's story"
# '\n'
# '\n'
# '\n'
# "\n    The Dormouse's story\n   "
# '\n'
# '\n'
# '\n   Once upon a time there were three little sisters; and their names were\n   '
# '\n    Elsie\n   '
# '\n   ,\n   '
# '\n    Lacie\n   '
# '\n   and\n   '
# '\n    Tillie\n   '
# '\n   ; and they lived at the bottom of a well.\n  '
# '\n'
# '\n   ...\n  '
# '\n'
# '\n'
# '\n'</code></pre>
<p>그리고 이런 문자열들은 개행문자(공백)이 쓸데 없이 많아서, <code>.stripped_strings</code> 를 사용해 제거할 수 있다.
그러면 문자열 앞, 뒤 공백과 공백만으로 구성된 문자열은 제거된다.</p>
<pre><code class="language-python">for string in soup.stripped_strings:
    print(repr(string))</code></pre>
<pre><code># "The Dormouse's story"
# "The Dormouse's story"
# 'Once upon a time there were three little sisters; and their names were'
# 'Elsie'
# ','
# 'Lacie'
# 'and'
# 'Tillie'
# '; and they lived at the bottom of a well.'
# '...'</code></pre>
<h3>올라가기</h3>
<p>태그마다 그리고 문자열마다 부모(.parent)가 있다.
한 요소의 부모는 <code>.parent</code> 속성으로 접근한다.
title 문자열 또한 부모가 있다.</p>
<pre><code class="language-python">title_tag = soup.title
print(title_tag.string.parent)
print(title_tag)
print(title_tag.parent)</code></pre>
<pre><code># &lt;title&gt;The Dormouse's story&lt;/title&gt;
# &lt;title&gt;The Dormouse's story&lt;/title&gt;
# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</code></pre>
<p><code>&lt;html&gt;</code> 태그와 같은 최상위 태그의 부모는 BeautifulSoup 객체 자신이다.
하지만 BeautifulSoup의 부모는 <code>None</code>으로 정의된다.</p>
<pre><code class="language-python">html_tag = soup.html
print(type(html_tag.parent))
print(soup.parent)</code></pre>
<pre><code># &lt;class 'bs4.BeautifulSoup'&gt;
# None</code></pre>
<p><code>.parents</code>로 한 요소의 부모를 모두 소환할 수 있다.</p>
<pre><code class="language-python">link = soup.a

for parent in link.parents:
    if parent is None:
        print(parent)
    else:
        print(parent.name)</code></pre>
<pre><code># p
# body
# html
# [document]</code></pre>
<p>예제에는 None까지 나오는데 안나온다</p>
<pre><code class="language-python">print(link.parent.parent.parent.parent.parent)</code></pre>
<pre><code># None</code></pre>
<p>이렇게 하면 나오는데, None은 <code>.parent</code>로만 확인할 수 있나보다.</p>
<h3>옆으로 가기</h3>
<pre><code class="language-python">sibling_soup = BeautifulSoup("&lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;",'html.parser')
print(sibling_soup.prettify())</code></pre>
<pre><code># &lt;html&gt;
#  &lt;body&gt;
#   &lt;a&gt;
#    &lt;b&gt;
#     text1
#    &lt;/b&gt;
#    &lt;c&gt;
#     text2
#    &lt;/c&gt;
#   &lt;/a&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre>
<p><code>&lt;b&gt;</code> 태그와 <code>&lt;c&gt;</code> 태그는 같은 수준에 있다. 둘 다 같은 태그의 직계 자식이다. 즉 형제들(siblings)이다.</p>
<h4>.next_sibling AND .previous_sibling</h4>
<p><code>.next_siling</code>과 <code>.previous_siling</code>을 사용하면 해석 트리에서 같은 수준에 있는 페이지 요소들 사이를 이동할 수 있다.</p>
<pre><code class="language-python">print(sibling_soup.b.next_sibling)
print(sibling_soup.c.previous_sibling)</code></pre>
<pre><code># &lt;c&gt;text2&lt;/c&gt;
# &lt;b&gt;text1&lt;/b&gt;</code></pre>
<p><code>&lt;b&gt;</code>태그는 <code>.next_sibling</code>이 있지만 <code>.previous_sibling</code>은 없다. <code>&lt;b&gt;</code>태그 앞에 트리에서 같은 수준에 아무것도 없기 때문이다.</p>
<p>문자열 'text1'과 'text2'는 형제 사이가 아니다. 왜냐하면 부모가 다르기 때문.</p>
<p>실제 문서에서, 한태그의 <code>.next_sibling</code>이나 <code>previous_sibling</code>은 보통 공백이 포함된 문자열이다.</p>
<pre><code class="language-python">link = soup.a
print(link)
print(link.next_sibling)</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;
#    ,</code></pre>
<p>실제로 두번째 <code>&lt;a&gt;</code> 태그는 쉼표의 <code>.next_sibling</code>이다.</p>
<pre><code class="language-python">print(link.next_sibling.next_sibling)</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;</code></pre>
<h4>.next_siblings AND .previous_siblings</h4>
<p>태그의 형제들은 <code>.next_siblings</code>이나 <code>.previous_siblings</code>로 반복할 수 있다.</p>
<pre><code class="language-python">for sibling in soup.a.next_siblings:
    print(repr(sibling))

for sibling in soup.find(id="link3").previous_siblings:
    print(repr(sibling))</code></pre>
<pre><code># '\n   ,\n   '
# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#     Lacie
#    &lt;/a&gt;
# '\n   and\n   '
# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#     Tillie
#    &lt;/a&gt;
# '\n   ; and they lived at the bottom of a well.\n  '
#
# '\n   and\n   '
# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#     Lacie
#    &lt;/a&gt;
# '\n   ,\n   '
# &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#     Elsie
#    &lt;/a&gt;
# '\n   Once upon a time there were three little sisters; and their names were\n   '
</code></pre>
<h3>앞뒤로 가기</h3>
<h4>.next_element AND .previous_element</h4>
<p>문자열이나 태그의 <code>.next_element</code>속성은 바로 다음에 해석된 것을 가리킨다. <code>.next_sibling</code>과 같을 것 같지만, 완전히 다르다</p>
<p>다음은 문서 마지막 <code>&lt;a&gt;</code> 태그이다. 그의 <code>.next_sibling</code>은 문자열이다. <code>&lt;a&gt;</code> 태그가 시작되어 중단되었던 문장의 끝부분이다.</p>
<p>그러나 <code>&lt;a&gt;</code> 태그의 <code>.next_element</code>는, 다시 말해 <code>&lt;a&gt;</code> 태그 바로 다음에 해석된 것은, 나머지 문장이 아니다. 그것은 단어 "Tilie"이다.
<code>&lt;a&gt; 태그</code> -&gt; <code>Tilie</code> -&gt; <code>&lt;/a&gt; 태그</code></p>
<pre><code class="language-python">last_a_tag = soup.find("a", id="link3")

print(last_a_tag)
print(last_a_tag.next_sibling)
print(last_a_tag.next_element)</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;
#    ; and they lived at the bottom of a well.
#     Tillie</code></pre>
<p><code>.previous_element</code> 속성은 <code>.next_element</code>와 정반대이다.</p>
<h4>.next_elements AND .previous_elements</h4>
<pre><code class="language-python">for element in last_a_tag.next_elements:
    print(repr(element))</code></pre>
<pre><code># '\n    Tillie\n   '
# '\n   ; and they lived at the bottom of a well.\n  '
# '\n'
# &lt;p class="story"&gt;
#    ...
#   &lt;/p&gt;
# '\n   ...\n  '
# '\n'
# '\n'
# '\n'</code></pre>
<h1>트리 검색하기</h1>
<p>BeautifulSoup에는 해석 트리 탐색읠 위한 매쏘드들이 많이 정의되어 있지만 거의 다 비슷하다. 그 중 <code>find()</code>와 <code>find_all()</code>이 가장 많이 쓰인다.</p>
<h3>필터의 종류</h3>
<p>find_all()_all()과 유가 메쏘드들에 관한 설명 전에, 이런 메쏘드들에 건낼 수 있는 다양한 여과기의 예제를 보여준다. 태그의 이름, 그의 속성, 문자열 텍스트 또는 이런 것들을 조합하여 여과할 수 있다.</p>
<h4>문자열</h4>
<p>가장 단순한 여과기이다. 다음 코드는 문서에서 "div" 태그를 모두 찾는다.</p>
<pre><code class="language-python">soup = BeautifulSoup('&lt;div class="my id" id="tag"&gt;hi&lt;/div&gt;',"html.parser")
string_1 =soup.find_all('div')

print(string_1)</code></pre>
<pre><code># [&lt;div class = "my id" id ="tag"&gt;hi&lt;/div&gt;]</code></pre>
<p>바이트 문자열을 건내면, beautifulsoup는 그 문자열이 UTF-8로 인코드 되어 있다고 간주한다. 이를 피하려면 유니코드 문자열을 건내면 된다.</p>
<h4>정규 표현식</h4>
<p>정규 표현식이란 문자열이 주어진 규칙에 일치하는지, 일치하지 않는지 판단하는 것이다.</p>
<p>예를 들어</p>
<ol>
<li>글자 a를 최소한 한 번 쓰시오.</li>
<li>그 뒤에 b를 정확히 다섯 개 쓰시오</li>
<li>그 뒤에 c를 짝수 번 쓰시오</li>
<li>마지막에 d가 있어도 되고 없어도 됩니다.</li>
</ol>
<p>이 규칙을 만족하는 정규 표현식은 <code>aa*bbbbb(cc)*(d | )</code> 이다.</p>
<ol>
<li>
<p>aa<em>
a</em>는 a가 몇 개든 상관없고 0개여도 된다는 뜻
즉 a는 최소한 한번은 있다는 뜻입니다.</p>
</li>
<li>
<p>bbbbb</p>
</li>
<li>
<p>(cc)<em>
c 두 개를 괄호 안에 쓰고 그 뒤에 </em>을 붙여 c의 쌍이 임의의 숫자만큼 있음을 나타냅니다. (0쌍이여도 규칙에는 맞습니다.)</p>
</li>
<li>
<p>(d | )
중간에 파이프문자는 '이거 아니면 저거'라는 뜻입니다. 여기에서는 'd' 다음에 공백을 쓰거나, 아니면 d 없이 공백만 쓴다'는 뜻이 됩니다.</p>
</li>
</ol>
<blockquote>
<p>정규 표현식은 <a href="http://regexpal.com">http://regexpal.com</a> 같은 웹에서 바로 테스트할 수 있습니다.</p>
</blockquote>
<p>정규 표현식 기호</p>
<table>
<thead>
<tr>
<th>기호</th>
<th>의미</th>
<th>예제</th>
<th>일치하는 문자열 예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>바로 앞에 있는 문자, 하위 표현식, 대괄호에 묶인 문자들이 <strong>0번 이상</strong> 나타납니다.</td>
<td>a<code>*</code>b<code>*</code></td>
<td>aaaaaaaa, aabbbbbb, bbbbbb</td>
</tr>
<tr>
<td>+</td>
<td>바로 앞에 있는 문자, 하위 표현식, 대괄호로 묶인 문자들이 <strong>1번 이상</strong> 나타납니다.</td>
<td>a+b+</td>
<td>aaaaab, aaabbbb, abbbb</td>
</tr>
<tr>
<td>[]</td>
<td><strong>대괄호 안에 있는 문자 중 하나</strong>가 나타납니다.</td>
<td>[A-Z]*</td>
<td>APPLE, CAPITALS, QWERTY</td>
</tr>
<tr>
<td>()</td>
<td><strong>그룹으로 묶인 하위 표현식</strong>입니다. 정규 표현식을 평가할때에는 하위 표현식이 가장 먼저 평가됩니다.</td>
<td>(a<code>*</code>b)<code>*</code></td>
<td>aaabaab, abaaab, ababaaaaab</td>
</tr>
<tr>
<td>{m, n}</td>
<td>바로 앞에 있는 문자, 하위 표현식, 대괄호로 묶인 문자들이 <strong>m번 이상, n번 이하</strong> 나타납니다.</td>
<td>a{2, 3} b{2, 3}</td>
<td>aabbb, aaabbb, aabb</td>
</tr>
<tr>
<td>[^]</td>
<td>대괄호 안에 잇는 문자를 제외한 문자가 나타납니다.</td>
<td>[^A-Z]*</td>
<td>apple, lowercase, qwerty</td>
</tr>
<tr>
<td><em>\</em></td>
<td><strong><em>\</em>로 분리된 문자, 문자열 하위 표현식 중 하나</strong>가 나타납니다. 는 '파이프'라 부르는 세로 막대이며 대문자 I가 아닙니다.</td>
<td>b(a<em>*i</em>*e)d</td>
<td>bad, bid, bed</td>
</tr>
<tr>
<td>.</td>
<td><strong>문자 하나(글자, 숫자, 기호, 공백 등)</strong>가 나타납니다.</td>
<td>b.d</td>
<td>bad, bzd, b$d, b d</td>
</tr>
<tr>
<td>^</td>
<td>바로 뒤에 있는 문자 혹은 하위 표현식이 <strong>문자열의 맨 앞</strong>에 나타납니다.</td>
<td>^a</td>
<td>apple, asdf, a</td>
</tr>
<tr>
<td>\</td>
<td><strong>특수 문자를 원래 의미대로 쓰게 하는</strong> 이스케이프 문자입니다.</td>
<td>\. \<em>\</em> \\</td>
<td>. <em>\</em> \</td>
</tr>
<tr>
<td>$</td>
<td><strong>정규 표현식 마지막에 종종 쓰이며, 바로 앞에 있는 문자 또는 하위 표현식이 문자열의 마지막이라는 뜻입니다.</strong> 이 기호를 쓰지 않는 정규 표현식은 사실상 .*가 마지막에 있는 것이나 마찬가지여서 그 뒤에 무엇이 있든 전부 일치합니다. ^ 기호의 반대라고 생각해도 됩니다.</td>
<td>[A-Z]<em>[a-z]</em>$</td>
<td>ABCabc, zzzyx, Bob</td>
</tr>
<tr>
<td>?!</td>
<td>'포함하지 않는다'는 뜻입니다. 이 기호 쌍 바로 다음에 있는 문자(또는 하위 표현식)는 해당 위치에 나타나지 않습니다. 이 기호는 조금 혼란스러울 수 있읍니다. 배제한 문자가 문자열의 다른 부분에는 나타나도 되니까요. 특정 문자를 완벽히 배제하려면 ^과 $를 앞뒤에 쓰십시오.</td>
<td>^((?![A-Z]).)*$</td>
<td>no-caps-here, $ymb0ls a4e f!ne</td>
</tr>
</tbody>
</table>
<p>해당 정규 표현식은 파이썬을 기준으로 작성되었습니다. 정규 표현식은 언어마다 다를 수 있습니다. 메뉴얼을 참고하세요</p>
<p>정규 표현식 객체를 건내면, beautifulsoup는 <code>match()</code> 메쏘드를 사용하여 그 정규 표현식에 맞게 여과한다.</p>
<pre><code class="language-html">&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;
   The Dormouse's story
  &lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p class="title"&gt;
   &lt;b&gt;
    The Dormouse's story
   &lt;/b&gt;
  &lt;/p&gt;
  &lt;p class="story"&gt;
   Once upon a time there were three little sisters; and their names were
   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
    Elsie
   &lt;/a&gt;
   ,
   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
    Lacie
   &lt;/a&gt;
   and
   &lt;a class="sister" href="http://example.com/tillie" id="link2"&gt;
    Tillie
   &lt;/a&gt;
   ; and they lived at the bottom of a well.
  &lt;/p&gt;
  &lt;p class="story"&gt;
   ...
  &lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>다음 코드는 이름이 'b'로 시작하는 태그를 모두 찾는다. 이 경우 <code>&lt;body&gt;</code> 태그와 <code>&lt;b&gt;</code> 태그를 찾을 것이다.</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
import re
soup = BeautifulSoup(html, "html.parser")

for tag in soup.find_all(re.compile("^b")):
    print(tag.name)</code></pre>
<pre><code># body
# b</code></pre>
<h4>리스트</h4>
<p>리스트를 건내면, beautifulsoup는 그 리스트에 담긴 항목마다 문자열 부합을 수행한다. 다음 코드는 <code>&lt;a&gt;</code> 태그 그리고 모든 <code>&lt;b&gt;</code> 태그를 찾는다.</p>
<pre><code class="language-python">list_ = soup.find_all(["a","b"])
print(list_)</code></pre>
<pre><code># [&lt;b&gt;
#   The Dormouse's story
#  &lt;/b&gt;, &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link2"&gt;
#   Tillie
#  &lt;/a&gt;]</code></pre>
<h4>True</h4>
<p>True 값은 참이면 모두 부합시킨다. 다음 코드는 문서에서 태그를 모두 찾지만, 텍스트 문자열은 전혀 찾지 않는다.</p>
<pre><code class="language-python">for tag in soup.find_all(True):
  print(tag.name)</code></pre>
<pre><code># html
# head
# title
# body
# p
# b
# p
# a
# a
# a
# p</code></pre>
<h3>find_all()</h3>
<blockquote>
<p>find_all(name, attrs, recursive, text, limit, keyword)</p>
</blockquote>
<p>find_all() 메소드는 태그의 후손들을 찾아서 지정한 여과기에 부합하면 모두 추출한다.</p>
<pre><code class="language-python">print(soup.find_all("title"))
print(soup.find_all("p", "title"))
print(soup.find_all("a"))
print(soup.find_all(id="link2"))
print(soup.find(text=re.compile("sisters")))</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]
# [&lt;p class="title"&gt;&lt;b&gt;    The Dormouse's story   &lt;/b&gt;&lt;/p&gt;]
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;]
#    Once upon a time there were three little sisters; and their names were</code></pre>
<h4>인자</h4>
<h5>name 매개변수</h5>
<p>태그 이름인 문자열을 넘기거나, 태그 이름으로 이루어진 파이썬 리스트를 넘길 수 있다.
텍스트 문자열은 무시된다.</p>
<pre><code class="language-python">print(soup.find_all("title"))</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</code></pre>
<h5>attrs 매개변수</h5>
<p>attrs 매개변수는 속성으로 이루어진 파이썬 딕셔너리를 받고, 그 중 하나에 일치하는 태그를 찾습니다.</p>
<pre><code class="language-python">print(soup.find_all(href=re.compile("elsie"), id='link1'))
print(soup.find_all(attrs={'href':re.compile("elsie"), 'id':'link1'}))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;]
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;]</code></pre>
<h6>CSS 클래스로 탐색하기</h6>
<p>특정 CSS 클래스를 가진 태그를 탐색하면 아주 유용하지만, CSS 속성의 이름인 "class"는 파이썬에서 예약어이다. 키워드 인자로 class를 사용하면 신텍스 에러(구문에러)가 발생한다. 따라서 <code>class_</code> 키워드 인자를 사용하면 된다.</p>
<pre><code class="language-python">print(soup.find_all("a", class_="sister"))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]</code></pre>
<p>다른 키워드 인자와 마찬가지로, <code>class_</code>에 문자열, 정규 표현식, 함수, True를 건낼 수 있다.</p>
<pre><code class="language-python">def has_six_characters(css_class):
    return css_class is not None and len(css_class) == 6

print(soup.find_all(class_=re.compile("itl")))

print(soup.find_all(class_=has_six_characters))</code></pre>
<pre><code># [&lt;p class="title"&gt;
# &lt;b&gt;
#   The Dormouse's story
#  &lt;/b&gt;
# &lt;/p&gt;]
#
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
</code></pre>
<p>하나의 태그에 "class" 속성에 대하여 값이 여러개 있을 수 있다. 특정 CSS 클래스에 부합하는 태그를 탐색할 때, CSS 클래스들 모두에 대하여 대조를 수행하는 것이다.
class 속성의 정확한 문자열 값을 탐색할 수도 있다.
그러나 문자열 값을 변현해서 탐색하면 작동하지 않는다.</p>
<pre><code class="language-python">css_soup = BeautifulSoup('&lt;p class="body strikeout"&gt;&lt;/p&gt;','html.parser')
print(css_soup.find_all("p", class_="strikeout"))
print(css_soup.find_all("p",class_="body"))
print(css_soup.find_all("p", class_="body strikeout"))
print(css_soup.find_all("p", class_="strikeout body"))</code></pre>
<pre><code># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]
# [&lt;p class="body strikeout"&gt;&lt;/p&gt;]
# [&lt;p class="body strikeout"&gt;&lt;/p&gt;]
# []</code></pre>
<p><code>class_</code>를 위한 간편한 방법이 beautifulsoup 모든 버전에 존재한다. <code>find()</code>유형의 메소드에 건내는 두번째 인자는 <code>attrs</code>인데, 문자열을 <code>attrs</code>에 건내면 그 문자열을 CSS 클래스처럼 탐색한다.</p>
<pre><code class="language-python">print(soup.find_all("a", "sister"))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]</code></pre>
<p>정규표현식, 함수, 딕셔너리, True 유형으로도 보낼 수 있다.</p>
<h5>recursive 매개변수</h5>
<p>recursive 매개변수는 불리언이다. 문서에 얼마나 깊이 찾아 들어가고 싶은지 지정할때 사용합니다. <code>True</code>이면 findAll 함수는 매개변수에 일치하는 태그를 찾아 자식, 손자를 검색합니다. <code>False</code>이면 직계 자식의 태그만 찾습니다.</p>
<pre><code class="language-python">print(soup.html.find_all("title"))
print(soup.html.find_all("title",recursive=False))</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]
# []</code></pre>
<pre><code>&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;
   The Dormouse's story
  &lt;/title&gt;
 &lt;/head&gt;</code></pre>
<p><code>&lt;title&gt;</code> 태그는 <code>&lt;html&gt;</code> 태그 아래에 있지만, <code>&lt;html&gt;</code> 태그 바로 아래에 있는 것은 아니다. <code>&lt;head&gt;</code> 태그가 사이에 있다. beautifulsoup는 <code>&lt;html&gt;</code> 태그의 모든 후손을 찾아 보도록 허용해야만 <code>&lt;샤싣&gt;</code>태그를 발견한다. 그러나 <code>recursive=false</code>가 <code>&lt;html&gt;</code>태그의 자식으로 검색을 제한하기 때문에 아무것도 하지 못한다.</p>
<p>beautifulsoup는 트리-탐색 메소드들을 다양하게 제공한다. 대부분 <code>find_all()</code>과 같은 <code>name, attrs, text, limit, keyword</code>인자를 취한다. 그러나 <code>recursive</code>인자는 다르다. <code>find_all()</code>과 <code>find()</code>만 유일하게 지원한다.</p>
<h5>text 매개변수</h5>
<p>text 매개변수는 태그의 속성이 아니라 텍스트 콘텐츠에 일치한다는 점이 다르다.</p>
<pre><code class="language-python">print(soup.find_all(text="Elsie"))
print(soup.find_all(text=["Tillie", "Elsie", "Lacie"]))
print(soup.find_all(text=re.compile("Dormouse")))</code></pre>
<pre><code># []
# []
# ["The Dormouse's story", "\n    The Dormouse's story\n   "]</code></pre>
<p>왜 안될까</p>
<pre><code># ['Elsie']
# ['Elsie', 'Lacie', 'Tillie']
# ["The Dormouse's story", "The Dormouse's story"]</code></pre>
<p>이렇게 나와야 하는데</p>
<blockquote>
<p>'\n    Elsie\n   ' 문자가 이모양이여서 그런거 같다.</p>
</blockquote>
<h5>limit 매개변수</h5>
<p><code>find_all()</code>에서만 쓰임 <code>find()</code>에서는 limit를 1로 고정.
페이지의 항목 처음 몇 개만 찾을때 사용한다.</p>
<pre><code class="language-python">print(soup.find_all("a", limit=2))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;]</code></pre>
<h5>keyword 매개변수</h5>
<p>keyword 매개변수는 특정 속성이 포함된 태그를 선택할 때 사용한다.</p>
<pre><code class="language-python">print(soup.find_all(id='link2'))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;]</code></pre>
<h3>find()</h3>
<blockquote>
<p>find(name, attrs, recursive, text, keyword)</p>
</blockquote>
<p><code>find_all()</code> 메소드는 전체 문서를 훓어서 결과를 찾지만, 어떤 경우는 결과를 하나만 원할 수도 있다.
<code>find_all()</code>메소드는 한개의 결과를 담은 리스트를 출력하고, <code>find()</code>메소드는 그냥 그 결과를 출력한다.
아무것도 찾지 못할때는 <code>find_all()</code>은 빈리스트를, <code>find()</code>는 None을 출력한다.</p>
<pre><code class="language-python">print(soup.find_all('title', limit=1))
print(soup.find('title'))</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre>
<p><code>soup.head.title</code>은 <code>find()</code>을 반복적으로 호출한다</p>
<pre><code class="language-python">print(soup.head.title)
print(soup.find("head").find("title"))</code></pre>
<pre><code># &lt;title&gt;The Dormouse's story&lt;/title&gt;
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre>
<h3>find_parents() AND find_parent()</h3>
<blockquote>
<p>find_parents(name, attrs, text, limit, **kwargs)</p>
<p>find_parent(name, attrs, text, **kwargs)</p>
</blockquote>
<p><code>find_all()</code>과 <code>find()</code>은 트리를 위에서 아래로 내려오면서 태그를 찾았다면, 위 메소드들은 아래에서 위로 올라가며 태그의 부모를 찾는다.</p>
<pre><code class="language-python">a_string = soup.find(text=re.compile("Lacie"))

print(a_string)
print(a_string.find_parents("a"))
print(a_string.find_parent("p"))
print(a_string.find_parents("p", class_="title"))</code></pre>
<pre><code>#   Lacie
#
# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;]
#
# &lt;p class="story"&gt;
#  Once upon a time there were three little sisters; and their names were
#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;
#  ,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;
#  and
#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;
#  ; and they lived at the bottom of a well.
# &lt;/p&gt;
#
# []</code></pre>
<h3>find_next_siblings() AND find_next_sibling()</h3>
<blockquote>
<p>find_next_siblings(name, attrs, text, limit, **kwargs)</p>
<p>find_next_sibling(name, attrs, text, **kwargs)</p>
</blockquote>
<p>이 메소드들은 <code>.next siblings</code>을 사용하여 트리에서 한 요소의 나머지 형제들을 반복해서 찾는다. <code>find_next_siblings()</code> 메소드는 만족하는 형제를 모두 찾고, <code>find_next_sibling()</code>메소드는 그 중 첫번째만 찾는다.</p>
<pre><code class="language-python">first_link = soup.a

print(first_link)
print(first_link.find_next_siblings("a"))

first_story_paragraph = soup.find("p", "story")

print(first_story_paragraph.find_next_sibling("p"))</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;
#
# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
#
# &lt;p class="story"&gt;
#  ...
# &lt;/p&gt;</code></pre>
<h3>find_previous_siblings() AND find_previous_sibling()</h3>
<blockquote>
<p>find_previous_siblings(name, attrs, text, limit, **kwargs)</p>
<p>find_previous_sibling(name, attrs, text, **kwargs)</p>
</blockquote>
<p>이 메소드는 <code>.previous siblings</code>를 사용하여 트리에서 한 원소의 앞에 나오는 형제들을 반복한다.
<code>find_previous_siblings()</code>메소드는 만족하는 형제 모두를 찾고, <code>find_previous_sibling()</code>는 첫째만 찾는다.</p>
<pre><code class="language-python">last_link = soup.find("a", id="link3")

print(last_link)
print(last_link.find_previous_siblings("a"))

first_story_paragraph = soup.find("p", "story")

print(first_story_paragraph.find_previous_sibling("p"))</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;
#
# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;]
#
# &lt;p class="title"&gt;
# &lt;b&gt;
#   The Dormouse's story
#  &lt;/b&gt;
# &lt;/p&gt;</code></pre>
<h3>find_all_next() 그리고 find_next()</h3>
<blockquote>
<p>find_all_next(name, attrs, text, limit, **kwargs)</p>
<p>find_next(name, attrs, text, **kwargs)</p>
</blockquote>
<p>이 메소드들은 <code>.next elements</code>를 사용하여 문서의 한 태그 뒤에 오는 태그 또는 문자열을 전부 반환한다. <code>find_all_next()</code>메소드는 만족하는 모든 것을, <code>find_next()</code>는 첫 번째만 찾는다.</p>
<pre><code class="language-python">first_link = soup.a
print(first_link)
print(first_link.find_all_next(text=True))
print(first_link.find_next("p"))</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;
#
# ['\n    Elsie\n   ', '\n   ,\n   ', '\n    Lacie\n   ', '\n   and\n   ', '\n    Tillie\n   ', '\n   ; and they lived at the bottom of a well.\n  ', '\n', '\n   ...\n  ', '\n', '\n', '\n']
#
# &lt;p class="story"&gt;
#  ...
# &lt;/p&gt;</code></pre>
<h3>find_all_previous() AND find_previous()</h3>
<blockquote>
<p>find_all_previous(name, attrs, text, limit, **kwargs)</p>
<p>find_previous(name, attrs, text, **kwargs)</p>
</blockquote>
<p>이 메소드들은 <code>.previous elements</code>를 사용하여 문서에서 앞에 오는 태그나 문자열들을 반복한다. <code>find_all_previous()</code>메소드는 만족하는 모든 것을, <code>find_previous()</code>는 첫 번째만 찾는다.</p>
<pre><code class="language-python">first_link = soup.a

print(first_link)
print(first_link.find_all_previous("p"))
print(first_link.find_previous("title"))</code></pre>
<pre><code># &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;
#
# [&lt;p class="story"&gt;
#  Once upon a time there were three little sisters; and their names were
#  &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;
#  ,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;
#  and
#  &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;
#  ; and they lived at the bottom of a well.
# &lt;/p&gt;, &lt;p class="title"&gt;
# &lt;b&gt;
#   The Dormouse's story
#  &lt;/b&gt;
# &lt;/p&gt;]
#
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre>
<h3>CSS 선택자</h3>
<p>BeautifulSoup는 <a href="https://www.w3.org/TR/CSS2/selector.html" title="CSS 선택자 표준">CSS 선택자 표준</a>의 부분집합을 지원한다. 그냥 문자열로 선택자를 구성하고 그것을 TAG의 <code>.select()</code>메소드 또는 beautifulsoup 객체 자체에 건내면 된다.</p>
<p>다음과 같이 태그를 검색할 수 있다.</p>
<pre><code class="language-python">print(soup.select("title"))</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</code></pre>
<p>다른 태그 아래의 태그를 찾을 수 있다.</p>
<pre><code class="language-python">print(soup.select("body a"))
print(soup.select("html head title"))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
#
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</code></pre>
<p>다른 태그 바로 아래에 있는 태그를 찾을 수 있다.</p>
<pre><code class="language-python">print(soup.select("head &gt; title"))
print(soup.select("p &gt; a"))
print(soup.select("body &gt; a"))</code></pre>
<pre><code># [&lt;title&gt;The Dormouse's story&lt;/title&gt;]
#
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
#
# []</code></pre>
<p>CSS 클래스로 태그를 찾는다</p>
<pre><code class="language-python">print(soup.select(".sister"))
print(soup.select("[class~=sister]"))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
#
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]</code></pre>
<p>ID로 태그를 찾는다</p>
<pre><code class="language-python">print(soup.select("#link1"))
print(soup.select("a#link2"))
print(soup.select("b#link3"))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;]
#
# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;]
#
# []</code></pre>
<p>속성이 존재하는지 테스트 한다.</p>
<pre><code class="language-python">print(soup.select('a[href]'))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]</code></pre>
<p>속성 값으로 태그를 찾는다.</p>
<pre><code class="language-python">print(soup.select('a[href="http://example.com/elsie"]'))
print(soup.select('a[href^="http://example.com/"]'))
print(soup.select('a[href$="tillie"]'))
print(soup.select('a[href*=".com/el"]'))</code></pre>
<pre><code># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;]
#
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;
#   Lacie
#  &lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
#
# [&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;
#   Tillie
#  &lt;/a&gt;]
#
# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;
#   Elsie
#  &lt;/a&gt;]</code></pre>
<p>select 안에 <code>href^/$/*</code>는 </p>
<table>
<thead>
<tr>
<th>기호</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>~로 시작</td>
</tr>
<tr>
<td>$</td>
<td>~로 끝</td>
</tr>
<tr>
<td>*</td>
<td>중간에 ~포함</td>
</tr>
</tbody>
</table>
<p>인듯 CSS SELECT 더 확인해봐야함</p>
<p>언어 코덱을 일치 시킨다.</p>
<pre><code class="language-python">multilingual_markup = """
 &lt;p lang="en"&gt;Hello&lt;/p&gt;
 &lt;p lang="en-us"&gt;Howdy, y'all&lt;/p&gt;
 &lt;p lang="en-gb"&gt;Pip-pip, old fruit&lt;/p&gt;
 &lt;p lang="fr"&gt;Bonjour mes amis&lt;/p&gt;
"""

multilingual_soup = BeautifulSoup(multilingual_markup,'html.parser')

print(multilingual_soup.select('p[lang|=en]'))</code></pre>
<pre><code># [&lt;p lang="en"&gt;Hello&lt;/p&gt;, &lt;p lang="en-us"&gt;Howdy, y'all&lt;/p&gt;, &lt;p lang="en-gb"&gt;Pip-pip, old fruit&lt;/p&gt;]</code></pre>
<p>이미 CSS selecto를 알고 있는 사람은 편리하게 사용할 수 있다. 당신은 모든 것을 beautifulsoup API와 함께 수행 할 수 있다. 만약 CSS selectors가 필요한경우 넌 lxml 해석기를 사용해야한다. 그것이 더 빠르다. 그러나 당신은 CSS selectors와 beautifulSoup API를 결합해서 사용할 수 있다.</p>
<h1>트리 수정하기</h1>
<p>beautifulSoup는 해석 트리를 검색하는 장점이 있다. 또한 해석 트리를 변형해서 HTML 또는 XML 문서로 저장할 수도 있다.</p>
<h3>태그 이름과 속성 바꾸기</h3>
<p>태그 이름을 바꾸고 그의 속성값들을 바꾸며, 새로 추가하고, 삭제할 수 있다.</p>
<pre><code class="language-python">soup = BeautifulSoup('&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;','html.parser')
tag = soup.b

tag.name = "blockquote"
tag['class'] = 'verybold'
tag['id'] = 1
print(tag)

del tag['class']
del tag['id']
print(tag)</code></pre>
<pre><code># &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;
# &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</code></pre>
<h3>.string 변경하기</h3>
<p>xormdml <code>.string</code>속성을 설정하면, 태그의 내용이 주어진 문자열로 교체된다.
태그에 또 다른 태그가 들어있다면, 그 태그는 물론 모든 내용이 사라진다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')

tag = soup.a
tag.string = "New link text."
print(tag)</code></pre>
<pre><code># &lt;a href="http://example.com/"&gt;New link text.&lt;/a&gt;</code></pre>
<h3>append()</h3>
<p><code>Tag.append()</code>로 태그에 내용을 추가할 수 있다. 파이썬 리스트에 <code>.append()</code>를 호출할 것과 똑같이 작동한다.</p>
<pre><code class="language-python">soup = BeautifulSoup("&lt;a&gt;Foo&lt;/a&gt;",'html.parser')
soup.a.append("Bar")

print(soup)
print(soup.a.contents)</code></pre>
<pre><code># &lt;a&gt;FooBar&lt;/a&gt;
# ['Foo', 'Bar']</code></pre>
<h4>BeautifulSoup.new_string() AND .new_tag()</h4>
<p>문자열을 문서에 추가하고 싶다면, 파이썬 문자열을 <code>append()</code>에 건내기만 하면 된다. 아니면 <code>BeautifulSoup.new_string()</code> 공장 메소드를 호출하면 된다.</p>
<pre><code class="language-python">soup = BeautifulSoup("&lt;b&gt;&lt;/b&gt;",'html.parser')
tag = soup.b
tag.append("Hello")
new_string = soup.new_string(" there")
tag.append(new_string)

print(tag)
print(tag.contents)</code></pre>
<pre><code># &lt;b&gt;Hello there&lt;/b&gt;
# ['Hello', ' there']</code></pre>
<p>완전히 새로 태그를 만들어야 한다면 <code>BeautifulSoup.new_tag()</code> 공장 메소드를 호출하면 된다.
오직 첫 번째 인자, 즉 태그 이름만 있으면 된다.</p>
<pre><code class="language-python">soup = BeautifulSoup("&lt;b&gt;&lt;/b&gt;",'html.parser')
original_tag = soup.b

new_tag = soup.new_tag("a", href="http://www.example.com")
original_tag.append(new_tag)
print(original_tag)
print(new_tag)

new_tag.string = "Link text."
print(original_tag)
print(new_tag)</code></pre>
<pre><code># &lt;b&gt;&lt;a href="http://www.example.com"&gt;&lt;/a&gt;&lt;/b&gt;
# &lt;a href="http://www.example.com"&gt;&lt;/a&gt;
# &lt;b&gt;&lt;a href="http://www.example.com"&gt;Link text.&lt;/a&gt;&lt;/b&gt;
# &lt;a href="http://www.example.com"&gt;Link text.&lt;/a&gt;</code></pre>
<p><code>.append()</code>는 값을 변수에 복사하는 방식이 아니라 링크 형식으로 연결해준다고 생각한다. C언어의 포인터 개념처럼</p>
<h3>insert()</h3>
<p><code>Tag.insert()</code>는 <code>Tag.append()</code>와 거의 같은데, 새 요소가 반드시 그의 부모의 <code>.contents</code>끝에 갈 필요는 없다. 원하는 위치에 삽입될 수 있다. 파이썬 리스트의 <code>.insert()</code>와 같다</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')
tag = soup.a

tag.insert(1, "but did not endorse ")
print(tag)
print(tag.contents)</code></pre>
<pre><code># &lt;a href="http://example.com/"&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;
# ['I linked to ', 'but did not endorse ', &lt;i&gt;example.com&lt;/i&gt;]</code></pre>
<h4>insert_before() AND insert_after()</h4>
<p><code>insert_before()</code>메소드는 태그나 문자열을 해석 트리에서 어떤 것 바로 앞에 삽입한다.</p>
<pre><code class="language-python">soup = BeautifulSoup("&lt;b&gt;stop&lt;/b&gt;",'html.parser')
tag = soup.new_tag("i")
tag.string = "Don't"
soup.b.string.insert_before(tag)

print(soup.b)</code></pre>
<pre><code># &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt;stop&lt;/b&gt;</code></pre>
<p><code>insert_after()</code>메소드는 해석 트리에서 다른 어떤 것 바로 뒤에 나오도록 태그나 문자열을 이동시킨다.</p>
<pre><code class="language-python">soup = BeautifulSoup("&lt;b&gt;stop&lt;/b&gt;",'html.parser')
tag = soup.new_tag("i")
tag.string = "Don't"

soup.b.string.insert_before(tag)
soup.b.i.insert_after(soup.new_string(" ever "))

print(soup.b)
print(soup.b.contents)</code></pre>
<pre><code># &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt; ever stop&lt;/b&gt;
# [&lt;i&gt;Don't&lt;/i&gt;, ' ever ', 'stop']</code></pre>
<p>i 바로 뒤에 insert 하도록</p>
<h3>clear()</h3>
<p><code>Tag.clear()</code>은 태그의 내용을 제거한다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')
tag = soup.a

tag.clear()
print(tag)</code></pre>
<pre><code># &lt;a href="http://example.com/"&gt;&lt;/a&gt;</code></pre>
<p>자신을 제외한 태그를 지우는 듯</p>
<h3>extract()</h3>
<p><code>PageElement.extract()</code>는 해석 트리에서 태그나 문자열을 제거한다. 추출하고 남은 태그나 문자열을 돌려준다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')
a_tag = soup.a
i_tag = soup.i.extract()

print(a_tag)
print(i_tag)

print(a_tag.parent)
print(i_tag.parent)

my_string = i_tag.string.extract()
print(my_string)
print(my_string.parent)

print(i_tag)</code></pre>
<pre><code># &lt;a href="http://example.com/"&gt;I linked to &lt;/a&gt;
# &lt;i&gt;example.com&lt;/i&gt;
#
# &lt;a href="http://example.com/"&gt;I linked to &lt;/a&gt;
# None
#
# example.com
# None
#
# &lt;i&gt;&lt;/i&gt;</code></pre>
<p>자기 자신만 남기고 다 제거</p>
<h3>decompose()</h3>
<p><code>Tag.decompose()</code>는 태그를 트리에서 제거한 다음, 그와 그의 내용물을 완전히 파괴한다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')
a_tag = soup.a
i_tag = soup.i.decompose()

print(a_tag)
print(i_tag)

print(a_tag.parent)
print(i_tag.parent)</code></pre>
<pre><code>Traceback (most recent call last):
  File "D:/source/test/beautifulsoup_test.py", line 50, in &lt;module&gt;
    print(i_tag.parent)
AttributeError: 'NoneType' object has no attribute 'parent'

# &lt;a href="http://example.com/"&gt;I linked to &lt;/a&gt;
# None
# &lt;a href="http://example.com/"&gt;I linked to &lt;/a&gt;</code></pre>
<p>자기 자신을 제거, 그래서 부모를 불렀을때 에러가 나온것</p>
<h3>replace_witg()</h3>
<p><code>PageElement.replace_with()</code>는 트리에서 태그나 문자열을 제거하고 그것을 지정한 태그나 문자열로 교체한다.
<code>replace_with()</code>는 교체된 후의 태그나 문자열을 돌려준다. 그래서 검사해 보거나 다시 트리의 다른 부분에 추가할 수 있다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')
a_tag = soup.a

new_tag = soup.new_tag("b")
new_tag.string = "example.net"
a_tag.i.replace_with(new_tag)

print(a_tag)</code></pre>
<pre><code># &lt;a href="http://example.com/"&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;
</code></pre>
<h3>wrap()</h3>
<p><code>PageElement.wrap()</code>는 지정한 태그에 요소를 둘러싸서 새로운 포장지를 돌려준다.</p>
<pre><code class="language-python">soup = BeautifulSoup("&lt;p&gt;I wish I was bold.&lt;/p&gt;",'html.parser')

print(soup.p.string.wrap(soup.new_tag("b")))
print(soup.b.wrap(soup.new_tag("div")))
print(soup.p.wrap(soup.new_tag("fo")))</code></pre>
<pre><code># &lt;b&gt;I wish I was bold.&lt;/b&gt;
# &lt;div&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/div&gt;
# &lt;fo&gt;&lt;p&gt;&lt;div&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/div&gt;&lt;/p&gt;&lt;/fo&gt;</code></pre>
<h3>unwrap()</h3>
<p><code>Tag.unwrap()</code>은 <code>wrap()</code>의 반대이다. 태그를 그 태그 안에 있는 것들로 교체한다.
<code>replace_with()</code>처럼, <code>unwrap()</code>은 교체된 후의 태그를 돌려준다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')
a_tag = soup.a

print(a_tag.i.unwrap())
print(a_tag)</code></pre>
<pre><code># &lt;i&gt;&lt;/i&gt;
# &lt;a href="http://example.com/"&gt;I linked to example.com&lt;/a&gt;</code></pre>
<p><code>a_tag.a.unwrap()</code> 자기 자신은 제거가 안되나보다, 애초에 교체니까 안되는거겠지</p>
<h1>출력</h1>
<h3>예쁘게 인쇄하기</h3>
<p><code>prettify()</code>메소드는 beautifulSoup 해석 트리를 멋지게 모양을 낸 유니코드 문자열로 변환한다</p>
<pre><code class="language-python">markup = '&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href="http://example.com/"&gt;\n...&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'
soup = BeautifulSoup(markup,'html.parser')

print(soup.prettify())
print(soup.a.prettify())</code></pre>
<pre><code># &lt;html&gt;
#  &lt;head&gt;
#  &lt;/head&gt;
#  &lt;body&gt;
#   &lt;a href="http://example.com/"&gt;
#    ...
#    &lt;a href="http://example.com/"&gt;
#     I linked to
#     &lt;i&gt;
#      example.com
#     &lt;/i&gt;
#    &lt;/a&gt;
#   &lt;/a&gt;
#  &lt;/body&gt;
# &lt;/html&gt;
#
# &lt;a href="http://example.com/"&gt;
#  ...
#  &lt;a href="http://example.com/"&gt;
#   I linked to
#   &lt;i&gt;
#    example.com
#   &lt;/i&gt;
#  &lt;/a&gt;
# &lt;/a&gt;</code></pre>
<h3>있는 그대로 인쇄하기</h3>
<p>멋진 모양 말고 그냥 문자열을 원한다면 <code>BeautifulSoup 객체</code>, 그 안의 Tag에 <code>unicode()</code>, <code>str()</code>을 호출하면 된다.
<code>encode()</code>를 호출하면 bytestring, <code>decode()</code>는 유니코드를 얻는다.</p>
<pre><code class="language-python">markup = '&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href="http://example.com/"&gt;\n...&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'
soup = BeautifulSoup(markup,'html.parser')

print(str(soup))</code></pre>
<pre><code># &lt;html&gt;
# &lt;head&gt;
# &lt;/head&gt;
# &lt;body&gt;
# &lt;a href="http://example.com/"&gt;
# ...&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>
<h3>출력 포멧</h3>
<p>formatter의 인자값을 <code>prettify()</code>, <code>encode()</code>, <code>decode()</code>에 제공하면 된다.</p>
<pre><code class="language-python">french = "&lt;p&gt;Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/p&gt;"
soup = BeautifulSoup(french, 'html.parser')</code></pre>
<h4>minimal</h4>
<p>문자열은 beautifulsoup가 유효한 HTML/XML을 생산한다고 확신할 만큼 처리된다.</p>
<pre><code class="language-python">print(soup.prettify(formatter="minimal"))</code></pre>
<pre><code># &lt;p&gt;
#  Il a dit &amp;lt;&amp;lt;Sacré bleu!&amp;gt;&amp;gt;
# &lt;/p&gt;</code></pre>
<h4>html</h4>
<p>beautifulsoup는 유니코드 문자를 가능한한 HTML로 변환한다.</p>
<pre><code class="language-python">print(soup.prettify(formatter="html"))</code></pre>
<pre><code># &lt;p&gt;
#  Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;
# &lt;/p&gt;</code></pre>
<h4>None</h4>
<p>beautifulsoup는 출력시 문자열을 건드리지 않는다. 가장 빠른 옵션이지만, BeautifulSoup를 유효하지 않은 생성으로 이끌수있다.</p>
<pre><code class="language-python">print(soup.prettify(formatter=None))

link_soup = BeautifulSoup('&lt;a href="http://example.com/?foo=val1&amp;bar=val2"&gt;A link&lt;/a&gt;','html.parser')
print(link_soup.a.encode(formatter=None))</code></pre>
<pre><code># &lt;p&gt;
#  Il a dit &lt;&lt;Sacré bleu!&gt;&gt;
# &lt;/p&gt;
#
# b'&lt;a href="http://example.com/?foo=val1&amp;bar=val2"&gt;A link&lt;/a&gt;'</code></pre>
<h4>함수</h4>
<p>Beautifulsoup는 문서에서 문자열과 속성 값에 대하여 하나하나 그 함수를 한 번 호출한다. 이 함수에서 무엇이든 할 수 있다.
다음은 문자열을 대문자로 바꾼다.</p>
<pre><code class="language-python">def uppercase(str):
    return str.upper()

print(soup.prettify(formatter=uppercase))</code></pre>
<pre><code># &lt;p&gt;
#  IL A DIT &lt;&lt;SACRÉ BLEU!&gt;&gt;
# &lt;/p&gt;</code></pre>
<h4>get_text()</h4>
<p>문서나 태그에서 텍스트 부분만 추출하고 싶다면, get_text() 메소드를 사용할 수 있다. 이 메소드는 문서나 태그 아래의 텍스트를, 유니코드 문자열 하나로 모두 돌려준다.</p>
<pre><code class="language-python">markup = '&lt;a href="http://example.com/"&gt;\nI linked to &lt;i&gt;example.com&lt;/i&gt;\n&lt;/a&gt;'
soup = BeautifulSoup(markup,'html.parser')

print(soup.get_text())
print(soup.i.get_text())</code></pre>
<pre><code># I linked to example.com
# example.com</code></pre>
<p>텍스트를 합칠때 사용될 문자열을 지정해 줄 수 있다.
텍스트의 앞, 뒤에 있는 공백을 지우게 할 수도 있다.
<code>_stripped_strings</code>를 사용해 텍스트를 직접 처리할 수도 있다.</p>
<pre><code class="language-python">print(soup.get_text("|"))
print(soup.get_text("|", strip=True))
print([text for text in soup.stripped_strings])</code></pre>
<pre><code># I linked to |example.com|
# I linked to|example.com
# ['I linked to', 'example.com']</code></pre>
<h1>Encodings</h1>
<p><code>xml parser 꼭 설치해서 해보시길</code></p>
<p>HTML이든 XML이든 문서는 ASCII나 UTF-8 같은 특정한 인코딩으로 작성된다. 그러나 문서를 뷰티플수프에 적재하면, <code>문서가 유니코드로 변환</code>되었음을 알게 될 것이다:</p>
<pre><code class="language-python">markup = "&lt;h1&gt;Sacr\xc3\xa9 bleu!&lt;/h1&gt;"
soup = BeautifulSoup(markup)

print(soup.h1)
print(soup.h1.string)</code></pre>
<pre><code># &lt;h1&gt;SacrÃ© bleu!&lt;/h1&gt;
# SacrÃ© bleu!</code></pre>
<p>마법이 아니다(확실히 좋은 것이다.). 뷰티플수프는 <code>Unicode, Dammit라는 하위 라이브러리를 사용하여 문서의 인코딩을 탐지하고 유니코드로 변환한다.</code> 자동 인코딩 탐지는 BeautifulSoup 객체의 <code>.original_encoding 속성</code>으로 얻을 수 있다:</p>
<pre><code class="language-python">print(soup.original_encoding)</code></pre>
<pre><code># 'utf-8'</code></pre>
<p><code>난 왜 None이 뜰까... 왜지...</code></p>
<p>Unicode, Dammit은 대부분 올바르게 추측하지만, 가끔은 실수가 있다. 가끔 올바르게 추측하지만, 문서를 바이트 하나 하나 오랫동안 탐색한 후에야 그렇다. 혹시 <code>문서의 인코딩을 미리 안다면, 그 인코딩을 BeautifulSoup 구성자에 from_encoding로 건네면</code> 실수를 피하고 시간을 절약할 수 있다.</p>
<p>다음은 ISO-8859-8로 작성된 문서이다. 이 문서는 Unicode, Dammit이 충분히 살펴보기에는 너무 짧아서, ISO-8859-7로 잘못 인식한다:</p>
<pre><code class="language-python">markup = "&lt;h1&gt;\xed\xe5\xec\xf9&lt;/h1&gt;"
soup = BeautifulSoup(markup,'html.parser')

print(soup.h1)
print(soup.original_encoding)</code></pre>
<pre><code># &lt;h1&gt;íåìù&lt;/h1&gt;
# 'ISO-8859-7'</code></pre>
<p><code>난 왜 None이 뜰까... 왜지... parser 문제인가</code></p>
<p>이를 해결하려면 올바른 from_encoding을 건네면 된다:</p>
<pre><code class="language-python">markup = "&lt;h1&gt;\xed\xe5\xec\xf9&lt;/h1&gt;"
soup = BeautifulSoup(markup,'html.parser' ,from_encoding="iso-8859-8")

print(soup.h1)
print(soup.original_encoding)</code></pre>
<pre><code># &lt;h1&gt;íåìù&lt;/h1&gt;
# None
#
# &lt;h1&gt;םולש&lt;/h1&gt;
#'iso8859-8'</code></pre>
<p><code>밑에처럼 나와야 하는데, 왜 난 위에처럼 나오는걸까</code></p>
<h3>출력 인코딩</h3>
<pre><code class="language-python">markup = b'''
 &lt;html&gt;
  &lt;head&gt;
   &lt;meta content="text/html; charset=ISO-Latin-1" http-equiv="Content-type" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
   &lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;
  &lt;/body&gt;
 &lt;/html&gt;
'''

soup = BeautifulSoup(markup, 'html.parser')
print(soup.prettify())</code></pre>
<pre><code># &lt;html&gt;
#  &lt;head&gt;
#   &lt;meta content="text/html; charset=utf-8" http-equiv="Content-type"/&gt;
#  &lt;/head&gt;
#  &lt;body&gt;
#   &lt;p&gt;
#    Sacré bleu!
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre>
<p><code>&lt;meta&gt;</code> 태그가 재작성 되었다 !</p>
<p>인코딩을 <code>prettify()</code>에 건낼 수 있다.</p>
<pre><code class="language-python">print(soup.prettify("latin-1"))
print(soup.p.encode("utf-8"))
print(soup.p.encode("latin-1"))</code></pre>
<pre><code># b'&lt;html&gt;\n &lt;head&gt;\n  &lt;meta content="text/html; charset=latin-1" http-equiv="Content-type"/&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;p&gt;\n   Sacr\xe9 bleu!\n  &lt;/p&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n'
# b'&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;'
# b'&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;'</code></pre>
<p>선택한 인코딩에서 표현이 불가능한 문자는 숫자의 XML개체 참조로 변환된다.</p>
<pre><code class="language-python">markup = u"&lt;b&gt;\N{SNOWMAN}&lt;/b&gt;"
snowman_soup = BeautifulSoup(markup, 'html.parser')
tag = snowman_soup.b

print(tag.encode("utf-8"))
print(tag.encode("latin-1"))
print(tag.encode("ascii"))</code></pre>
<pre><code># b'&lt;b&gt;\xe2\x98\x83&lt;/b&gt;'
# b'&lt;b&gt;&amp;#9731;&lt;/b&gt;'
# b'&lt;b&gt;&amp;#9731;&lt;/b&gt;'
#
# &lt;b&gt;☃&lt;/b&gt;
# &lt;b&gt;&amp;#9731;&lt;/b&gt;
# &lt;b&gt;&amp;#9731;&lt;/b&gt;</code></pre>
<p><code>밑에처럼 나와야 하는데 왜 위에처럼 나올까..</code></p>
<h1>UnicodeDammit</h1>
<p>뷰티플수프를 사용하지 않더라도 유니코드를 사용할 수 있다. 인코딩을 알 수 없는 데이터가 있을 때마다 그냥 유니코드가 되어 주었으면 하고 바라기만 하면 된다:</p>
<pre><code class="language-python">from bs4 import UnicodeDammit
dammit = UnicodeDammit("Sacr\xc3\xa9 bleu!")

print(dammit.unicode_markup)
print(dammit.original_encoding)</code></pre>
<pre><code># SacrÃ© bleu!
# None
#
# Sacré bleu!
# 'utf-8'</code></pre>
<p><code>왜 original_encoding만 제대로 작동을 안할까</code></p>
<p>유니코드에 더 많은 데이터를 줄 수록, Dammit은 더 정확하게 추측할 것이다. 나름대로 어떤 인코딩일지 짐작이 간다면, 그것들을 리스트로 건넬 수 있다:</p>
<pre><code class="language-python">dammit = UnicodeDammit("Sacr\xe9 bleu!", ["latin-1", "iso-8859-1"])

print(dammit.unicode_markup)
print(dammit.original_encoding)</code></pre>
<pre><code># Sacré bleu!
# None
#
# Sacré bleu!
# 'latin-1'</code></pre>
<p>Unicode, Dammit는 뷰티플수프가 사용하지 않는 특별한 특징이 두 가지 있다.</p>
<h3>지능형 따옴표</h3>
<p>Unicode, Dammit을 사용하여 마이크로소프트 지능형 따옴표를 HTML이나 XML 개체로 변환할 수 있다:</p>
<pre><code class="language-python">from bs4 import UnicodeDammit

markup = b"&lt;p&gt;I just \x93love\x94 Microsoft Word\x92s smart quotes&lt;/p&gt;"

print(UnicodeDammit(markup, ["windows-1252"], smart_quotes_to="html").unicode_markup)
print(UnicodeDammit(markup, ["windows-1252"], smart_quotes_to="xml").unicode_markup)</code></pre>
<pre><code># &lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;
# &lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;</code></pre>
<p>또 마이크로소프트 지능형 따옴표를 ASCII 따옴표로 변환할 수 있다:</p>
<pre><code class="language-python">print(UnicodeDammit(markup, ["windows-1252"], smart_quotes_to="ascii").unicode_markup)</code></pre>
<pre><code># &lt;p&gt;I just "love" Microsoft Word's smart quotes&lt;/p&gt;</code></pre>
<p>모쪼록 이 특징이 쓸모가 있기를 바라지만, 뷰티플수프는 사용하지 않는다. 뷰티플수프는 기본 행위를 선호하는데, 기본적으로 마이크로소프트 지능형 따옴표를 다른 모든 것과 함께 유니코드 문자로 변환한다:</p>
<pre><code class="language-python">print(UnicodeDammit(markup, ["windows-1252"]).unicode_markup) UnicodeDammit(markup, ["windows-1252"]).unicode_markup</code></pre>
<pre><code># &lt;p&gt;I just “love” Microsoft Word’s smart quotes&lt;/p&gt;</code></pre>
<h3>비 일관적인 인코딩</h3>
<p>어떤 경우 문서 대부분이 UTF-8이지만, 안에 (역시) 마이크로소프트 지능형 따옴표와 같이 Windows-1252 문자가 들어 있는 경우가 있다. 한 웹 사이트에 여러 소스로 부터 데이터가 포함될 경우에 이런 일이 일어날 수 있다. UnicodeDammit.detwingle()을 사용하여 그런 문서를 순수한 UTF-8 문서로 변환할 수 있다. 다음은 간단한 예이다:</p>
<pre><code class="language-python">snowmen = (u"\N{SNOWMAN}" * 3)
quote = (u"\N{LEFT DOUBLE QUOTATION MARK}I like snowmen!\N{RIGHT DOUBLE QUOTATION MARK}")
doc = snowmen.encode("utf8") + quote.encode("windows_1252")</code></pre>
<p>이 문서는 뒤죽박죽이다. 눈사람은 UTF-8인데 따옴표는 Windows-1252이다. 눈사람 아니면 따옴표를 화면에 나타낼 수 있지만, 둘 다 나타낼 수는 없다:</p>
<pre><code class="language-python">print(doc)
print(doc.decode("windows-1252"))</code></pre>
<pre><code># b'\xe2\x98\x83\xe2\x98\x83\xe2\x98\x83\x93I like snowmen!\x94'
#â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”
#
# ☃☃☃�I like snowmen!�
# â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</code></pre>
<p><code>하..</code></p>
<p>문서를 UTF-8로 디코딩하면 UnicodeDecodeError가 일어나고, Windows-1252로 디코딩하면 알 수 없는 글자들이 출력된다. 다행스럽게도, UnicodeDammit.detwingle()는 그 문자열을 순수 UTF-8로 변환해 주므로, 유니코드로 디코드하면 눈사람과 따옴표를 동시에 화면에 보여줄 수 있다:</p>
<pre><code class="language-python">new_doc = UnicodeDammit.detwingle(doc)
print(new_doc.decode("utf8"))</code></pre>
<pre><code># ☃☃☃“I like snowmen!”</code></pre>
<p><code>처음으로 봤네 저 눈사람</code></p>
<p>UnicodeDammit.detwingle()는 오직 UTF-8에 임베드된 (또는 그 반대일 수도 있지만) Windows-1252을 다루는 법만 아는데, 이것이 가장 일반적인 사례이다.</p>
<p>BeautifulSoup이나 UnicodeDammit 구성자에 건네기 전에 먼저 데이터에 UnicodeDammit.detwingle()을 호출하는 법을 반드시 알아야 한다. 뷰티플수프는 문서에 하나의 인코딩만 있다고 간주한다. 그것이 무엇이든 상관없이 말이다. UTF-8과 Windows-1252를 모두 포함한 문서를 건네면, 전체 문서가 Windows-1252라고 생각할 가능성이 높고, 그 문서는 다음 <code>â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”</code>처럼 보일 것이다.</p>
<p>UnicodeDammit.detwingle()은 뷰티플수프 4.1.0에서 새로 추가되었다.</p>
<h1>Troubleshooting</h1>
<table>
<thead>
<tr>
<th>종류</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>SyntaxError: Invalid syntax (다음 ROOT_TAG_NAME = u'[document]' 줄에서)</td>
<td>코드를 변경하지 않고서, 파이썬 2 버전의 뷰티플수프를 파이썬 3 아래에서 사용하기 때문에 야기된다.</td>
</tr>
<tr>
<td>ImportError: No module named HTMLParser</td>
<td>파이썬 2 버전의 뷰티플수프를 파이썬 3 아래에서 사용하기 때문에 야기된다.</td>
</tr>
<tr>
<td>ImportError: No module named html.parser</td>
<td>파이썬 3 버전의 뷰티플수프를 파이썬 2에서 실행하기 때문에 야기된다.</td>
</tr>
<tr>
<td>ImportError: No module named BeautifulSoup</td>
<td>뷰티플수프 3 코드를 BS3가 설치되어 있지 않은 시스템에서 실행할 때 야기된다. 또는 꾸러미 이름이 bs4로 바뀌었음을 알지 못하고 뷰티플수프 4 코드를 실행하면 야기된다.</td>
</tr>
<tr>
<td>ImportError: No module named bs4</td>
<td>뷰티플수프 4 코드를 BS4가 설치되어 있지 않은 시스템에서 실행하면 야기된다.</td>
</tr>
</tbody>
</table>
<h1>기타 해석기 문제</h1>
<ul>
<li>스크립트가 한 컴퓨터에서는 잘 되는데 다른 컴퓨터에서는 작동하지 않는다면, 아마도 두 컴퓨터가 다른 해석기를 가지고 있기 때문일 것이다. 예를 들어, lxml이 설치된 컴퓨터에서 스크립트를 개발해 놓고, 그것을 html5lib만 설치된 컴퓨터에서 실행하려고 했을 수 있다. 왜 이것이 문제가 되는지는 해석기들 사이의 차이점을 참고하고, BeautifulSoup 구성자에 특정 라이브러리를 지정해서 문제를 해결하자.</li>
<li>HTMLParser.HTMLParseError: malformed start tag or HTMLParser.HTMLParseError: bad end tag - 파이썬의 내장 HTML 해석기에 처리가 불가능한 문서를 건네면 야기된다. 다른 HTMLParseError도 아마 같은 문제일 것이다. 해결책: lxml이나 html5lib를 설치하자.</li>
<li>알고 있는데 문서에서 그 태그를 발견할 수 없다면 (다시 말해, find_all()이 []를 돌려주거나 find()가 None을 돌려줄 경우), 아마도 파이썬의 내장 HTML 해석기를 사용하고 있을 가능성이 높다. 이 해석기는 가끔 이해하지 못하면 그 태그를 무시하고 지나간다. 해결책: lxml이나 html5lib를 설치하자.</li>
<li>HTML 태그와 속성은 대소문자를 구별하므로, 세가지 HTML 해석기 모두 태그와 속성 이름을 소문자로 변환한다. 다시 말해, 다음 조판 <TAG></TAG>는 <tag></tag>로 변환된다. 태그와 속성에 대소문자 혼합 또는 대문자를 그대로 유지하고 싶다면, 문서를 XML로 해석할 필요가 있다.</li>
</ul>
<p><code>세번째 ...</code></p>
<h1>더 자세한 사항은</h1>
<p>아래 참고 문헌을 참고해주세요..</p>
<h1>참고문헌</h1>
<blockquote>
<p>Beautiful Soup 4.4.0 documentation, "<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.html">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.html</a>"</p>
<p>라이언 미첼, 『파이썬으로 웹 크롤러 만들기』, 한빛미디어(2017)</p>
</blockquote>
        </article>
        
            <div class="my-4 text-center">
    <h5 class="serif bg-dark p-4"><a href="/@mildsalmon/series/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%AA%A8%EB%93%88-%EB%AC%B8%EC%84%9C" class="text-decoration-none text-white">'파이썬 모듈 문서' 시리즈</a></h5>
    <div class="row justify-content-between">
        <div class="col-md-6">
        
        </div>
        <div class="col-md-6">
        
            <div class="col-md-12 bg-light rounded p-3 mt-3">
                <a class="text-decoration-none deep-dark" href="/@mildsalmon/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%8B%9C%EB%A6%AC%EC%A6%88-%EC%84%A4%EB%AA%85?series=파이썬-모듈-문서">
                    <i class="fas fa-arrow-circle-right vivid-purple"></i><br>파이썬 모듈 시리즈 설명
                </a>
            </div>
        
        </div>
    </div>
</div>
        
        
        
        <ul class="tag-list">
            
            <li><a href="/@mildsalmon/topic/beautifulsoup">beautifulsoup</a></li>
            
            <li><a href="/@mildsalmon/topic/beautifulsoup4">beautifulsoup4</a></li>
            
            <li><a href="/@mildsalmon/topic/document">document</a></li>
            
            <li><a href="/@mildsalmon/topic/python">python</a></li>
            
            <li><a href="/@mildsalmon/topic/%EB%AA%A8%EB%93%88">모듈</a></li>
            
        </ul>
    </div>
    <div class="col-lg-2 mobile-disable">
        <div id="article-nav" class="sticky-top sticky-top-100"></div>
    </div>
</div>

<div id="comment" class="mt-5">
    
        
        <div id="comment-empty" class="comment-list">
            <p>작성된 댓글이 없습니다!</p>
        </div>
        
    
</div>


    
    <div class="alert alert-warning">로그인된 사용자만 댓글을 작성할 수 있습니다.</div>
    

</div>
</div>
<div class="rel-posts">
    <div class="container pt-4 pb-2">
        <div class="header-title">
            <h4 class="serif">이 작성자가 게시한 다른 글</h4>
        </div>
        <div class="row">
        
            <div class="col-md-4">
                <a href="/@mildsalmon/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%8B%9C%EB%A6%AC%EC%A6%88-%EC%84%A4%EB%AA%85"><div class="back-image rel-post-image" style="background-image: url(https://static.blex.kr/assets/images/default-post.png);"></div></a>
                <h5 class="serif pt-3 pb-4 ns"><a class="deep-dark" href="/@mildsalmon/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%8B%9C%EB%A6%AC%EC%A6%88-%EC%84%A4%EB%AA%85">파이썬 모듈 시리즈 설명</a></h5>
            </div>
        
            <div class="col-md-4">
                <a href="/@mildsalmon/os"><div class="back-image rel-post-image" style="background-image: url(https://static.blex.kr/title/mildsalmon/2020/2/17/18cGQe.png);"></div></a>
                <h5 class="serif pt-3 pb-4 ns"><a class="deep-dark" href="/@mildsalmon/os">OS document</a></h5>
            </div>
        
            <div class="col-md-4">
                <a href="/@mildsalmon/telegram"><div class="back-image rel-post-image" style="background-image: url(https://static.blex.kr/title/mildsalmon/2020/2/17/15Qb1t.png);"></div></a>
                <h5 class="serif pt-3 pb-4 ns"><a class="deep-dark" href="/@mildsalmon/telegram">Python Telegram Bot document</a></h5>
            </div>
        
        </div>
    </div>
</div>

        </div>
    </div>
    
    <footer class="page-footer font-small bg-theme">
    </div>
        <div class="footer-copyright text-center py-3">Copyright 2019 &copy; <a style="color:#fff" href="https://im.baejino.com">BaeJino</a>.
    </div>
</footer>

    <script type="text/javascript" src="https://static.blex.kr/assets/library/jquery.js"></script>
    <script type="text/javascript" src="https://static.blex.kr/assets/library/bootstrap.js"></script>
    <script type="text/javascript" src="https://static.blex.kr/assets/js/main.js?version=1.0.36"></script>
    <script type="text/javascript" src="https://static.blex.kr/assets/js/renderer.js?version=1.0.36"></script>
    <script type="text/javascript" src="https://static.blex.kr/assets/js/notify.js?version=1.0.36"></script>
    <div id="notify-content"></div>
    
<script type="text/javascript" src="https://static.blex.kr/assets/library/prism.js"></script>
<script type="text/javascript" src="https://static.blex.kr/assets/library/autolink.js"></script>
<script type="text/javascript" src="https://static.blex.kr/assets/js/posts.js?version=1.0.36"></script>
<script type="text/javascript" src="https://static.blex.kr/assets/js/user.js?version=1.0.36"></script>

<script type="text/javascript" src="https://static.blex.kr/assets/js/navigation.js?version=1.0.36"></script>

<script>
$(document).ready(function() {
  var csrftoken = getCookie('csrftoken');
  $.ajaxSetup({
    beforeSend: function(xhr, settings) {
      if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
        xhr.setRequestHeader("X-CSRFToken", csrftoken);
      }
    }
  });
});
</script>

    
</body>
</html>
